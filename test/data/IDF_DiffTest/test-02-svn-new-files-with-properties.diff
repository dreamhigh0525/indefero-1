Index: LinuxBIOSv1/src/include/cpu/i786/cpufixup.h
===================================================================
--- LinuxBIOSv1/src/include/cpu/i786/cpufixup.h	(Revision 0)
+++ LinuxBIOSv1/src/include/cpu/i786/cpufixup.h	(Revision 665)
@@ -0,0 +1,11 @@
+#ifndef CPU_I786_CPUFIXUP_H
+#define CPU_I786_CPUFIXUP_H
+
+
+void i786_cpufixup(struct mem_range *mem);
+
+#define L3_CACHE_DISABLE 0x40
+
+#endif /* CPU_I786_CPUFIXUP_H */
+
+

Eigenschaftsänderungen: LinuxBIOSv1\src\include\cpu\i786\cpufixup.h
___________________________________________________________________
Hinzugefügt: svn:keywords
   + Author Date Id Revision
Hinzugefügt: svn:eol-style
   + native

Index: LinuxBIOSv1/src/mainboard/tyan/guiness/cmos.layout
===================================================================
--- LinuxBIOSv1/src/mainboard/tyan/guiness/cmos.layout	(Revision 0)
+++ LinuxBIOSv1/src/mainboard/tyan/guiness/cmos.layout	(Revision 665)
@@ -0,0 +1,63 @@
+entries
+
+#start-bit length  config config-ID    name
+#0            8       r       0        seconds
+#8            8       r       0        alarm_seconds
+#16           8       r       0        minutes
+#24           8       r       0        alarm_minutes
+#32           8       r       0        hours
+#40           8       r       0        alarm_hours
+#48           8       r       0        day_of_week
+#56           8       r       0        day_of_month
+#64           8       r       0        month
+#72           8       r       0        year
+#80           4       r       0        rate_select
+#84           3       r       0        REF_Clock
+#87           1       r       0        UIP
+#88           1       r       0        auto_switch_DST
+#89           1       r       0        24_hour_mode
+#90           1       r       0        binary_values_enable
+#91           1       r       0        square-wave_out_enable
+#92           1       r       0        update_finished_enable
+#93           1       r       0        alarm_interrupt_enable
+#94           1       r       0        periodic_interrupt_enable
+#95           1       r       0        disable_clock_updates
+#96         288       r       0        temporary_filler
+0          384       r       0        reserved_memory
+384          1       e       4        boot_option
+385          1       e       4        last_boot
+386          3       e       5        baud_rate
+392          4       e       6        debug_level
+396          1       e       1        power_on_after_fail
+#401          1       e       1        ECC_memory
+#402          1       e       2        hda_disk
+#403          1       e       2        hdb_disk
+#404          1       e       2        hdc_disk
+#405          1       e       2        hdd_disk
+#406          2       e       7        boot_device
+
+enumerations
+
+#ID value   text
+1     0     Disable
+1     1     Enable
+#2     0     No
+#2     1     Yes
+4     0     Fallback
+4     1     Normal
+5     0     115200
+5     1     57600
+5     2     38400
+5     3     19200
+5     4     9600
+5     5     4800
+5     6     2400
+5     7     1200
+6     6     Notice
+6     7     Info
+6     8     Debug
+6     9     Spew
+#7     0     Network
+#7     1     HDD
+#7     2     Floppy
+#7     3     ROM

Eigenschaftsänderungen: LinuxBIOSv1\src\mainboard\tyan\guiness\cmos.layout
___________________________________________________________________
Hinzugefügt: svn:keywords
   + Author Date Id Revision
Hinzugefügt: svn:eol-style
   + native

Index: LinuxBIOSv1/src/config/linuxbios_c.ld
===================================================================
--- LinuxBIOSv1/src/config/linuxbios_c.ld	(Revision 0)
+++ LinuxBIOSv1/src/config/linuxbios_c.ld	(Revision 665)
@@ -0,0 +1,105 @@
+/*
+ *	Memory map:
+ *
+ *	_RAMBASE		
+ *				: data segment
+ *				: bss segment
+ *				: heap
+ *				: stack
+ */
+/*
+ * Bootstrap code for the STPC Consumer
+ * Copyright (c) 1999 by Net Insight AB. All Rights Reserved.
+ *
+ * $Id$
+ *
+ */
+
+/*
+ *	Written by Johan Rydberg, based on work by Daniel Kahlin.
+ *      Rewritten by Eric Biederman
+ */
+/*
+ *	We use ELF as output format. So that we can
+ *	debug the code in some form. 
+ */
+INCLUDE ldoptions
+
+ENTRY(_start)
+
+SECTIONS
+{
+	. = _RAMBASE;
+	/*
+	 * First we place the code and read only data (typically const declared).
+	 * This get placed in rom.
+	 */
+	.text : {
+		_text = .;
+		*(.text);
+		*(.text.*);
+		. = ALIGN(16);
+		_etext = .;
+	}
+	.rodata : {
+		_rodata = .;
+		. = ALIGN(4);
+		streams = . ;
+		*(.rodata.streams)
+		estreams = .;
+		. = ALIGN(4);
+		pci_drivers = . ;
+		*(.rodata.pci_drivers)
+		epci_drivers = . ;
+		*(.rodata)
+		*(.rodata.*)
+		_erodata = .;
+	}	
+	/*
+	 * After the code we place initialized data (typically initialized
+	 * global variables). This gets copied into ram by startup code.
+	 * __data_start and __data_end shows where in ram this should be placed,
+	 * whereas __data_loadstart and __data_loadend shows where in rom to
+	 * copy from.
+	 */
+	.data : {
+		_data = .;
+		*(.data)
+		_edata = .;
+	}
+	/*
+	 * bss does not contain data, it is just a space that should be zero
+	 * initialized on startup. (typically uninitialized global variables)
+	 * crt0.S fills between _bss and _ebss with zeroes.
+	 */
+	_bss = .;
+	.bss . : {
+		*(.bss)
+		*(.sbss)
+		*(COMMON)
+	}
+	_ebss = .;
+	_end = .;
+	_stack = .;
+	.stack . : {
+		/* Reserve a stack for each possible cpu, +1 extra */
+		. = ((MAX_CPUS * STACK_SIZE) + STACK_SIZE) ; 
+	}
+	_estack = .;
+	_heap = .;
+	.heap . : {
+		/* Reserve 256K for the heap */
+		. = HEAP_SIZE ;
+		. = ALIGN(4);
+	}
+	_eheap = .;
+	/* The ram segment
+ 	 * This is all address of the memory resident copy of linuxBIOS.
+	 */
+	_ram_seg = _text;
+	_eram_seg = _eheap;
+	/DISCARD/ : {
+		*(.comment)
+		*(.note)
+	}
+}

Eigenschaftsänderungen: LinuxBIOSv1\src\config\linuxbios_c.ld
___________________________________________________________________
Hinzugefügt: svn:keywords
   + Author Date Id Revision
Hinzugefügt: svn:eol-style
   + native

Index: LinuxBIOSv1/src/arch/i386/include/arch/rom_segs.h
===================================================================
--- LinuxBIOSv1/src/arch/i386/include/arch/rom_segs.h	(Revision 0)
+++ LinuxBIOSv1/src/arch/i386/include/arch/rom_segs.h	(Revision 665)
@@ -0,0 +1,10 @@
+#ifndef ROM_SEGS_H
+#define ROM_SEGS_H
+
+#define ROM_CODE_SEG 0x08
+#define ROM_DATA_SEG 0x10
+
+#define CACHE_RAM_CODE_SEG 0x18
+#define CACHE_RAM_DATA_SEG 0x20
+
+#endif /* ROM_SEGS_H */

Eigenschaftsänderungen: LinuxBIOSv1\src\arch\i386\include\arch\rom_segs.h
___________________________________________________________________
Hinzugefügt: svn:keywords
   + Author Date Id Revision
Hinzugefügt: svn:eol-style
   + native

Index: LinuxBIOSv1/src/arch/i386/lib/c_start.S
===================================================================
--- LinuxBIOSv1/src/arch/i386/lib/c_start.S	(Revision 0)
+++ LinuxBIOSv1/src/arch/i386/lib/c_start.S	(Revision 665)
@@ -0,0 +1,135 @@
+#include <arch/asm.h>
+#include <arch/intel.h>
+#ifdef SMP
+#include <cpu/p6/apic.h>
+#endif
+	.section ".text"
+	.code32
+	.globl _start
+_start:
+	cli
+	lgdt	%cs:gdtaddr
+	ljmp	$0x10, $1f
+1:	movl	$0x18, %ax
+	movl	%eax, %ds
+	movl	%eax, %es
+	movl	%eax, %ss
+	movl	%eax, %fs
+	movl	%eax, %gs
+
+	intel_chip_post_macro(0x13)		/* post 12 */
+
+	/** clear stack */
+	leal	EXT(_stack), %edi
+	movl	$EXT(_estack), %ecx
+	subl	%edi, %ecx
+	xorl	%eax, %eax
+	rep
+	stosb
+
+	/** clear bss */
+	leal	EXT(_bss), %edi
+	movl	$EXT(_ebss), %ecx
+	subl	%edi, %ecx
+	jz	.Lnobss
+	xorl	%eax, %eax
+	rep
+	stosb
+.Lnobss:
+
+	/* set new stack */
+	movl	$_estack, %esp
+#ifdef SMP
+	/* Get the cpu id */
+	movl	$APIC_DEFAULT_BASE, %edi
+	movl	APIC_ID(%edi), %eax
+	shrl	$24, %eax
+
+	/* Get the cpu index (MAX_CPUS on error) */
+	movl	$-4, %ebx
+1:	addl	$4, %ebx
+	cmpl	$(MAX_CPUS << 2), %ebx
+	je	2
+	cmpl	%eax, EXT(initial_apicid)(%ebx)
+	jne	1b
+2:	shrl	$2, %ebx
+
+	/* Now compute the appropriate stack */
+	movl	%ebx, %eax
+	movl	$STACK_SIZE, %ebx
+	mull	%ebx
+	subl	%eax, %esp
+
+	/* push the boot_complete flag */
+	pushl	%ebp
+
+	/* Save the stack location */
+	movl	%esp, %ebp
+
+	/*
+	 *	Now we are finished. Memory is up, data is copied and
+	 *	bss is cleared.   Now we call the main routine and
+	 *	let it do the rest.
+	 */ 
+	intel_chip_post_macro(0xfe)	/* post fe */
+
+	/* Resort the stack location */
+	movl	%ebp, %esp
+	
+	/* The boot_complete flag has already been pushed */
+	call	EXT(hardwaremain)
+	/*NOTREACHED*/
+.Lhlt:
+	intel_chip_post_macro(0xee)	/* post fe */
+	hlt
+	jmp	.Lhlt
+#endif
+
+
+	.globl gdt, gdt_end, gdt_limit
+
+gdt_limit = gdt_end - gdt - 1 /* compute the table limit */
+gdtaddr:
+	.word	gdt_limit
+	.long	gdt                /* we know the offset */
+
+gdt:
+// selgdt 0
+	.word	0x0000, 0x0000		/* dummy */
+	.byte	0x00, 0x00, 0x00, 0x00
+
+// selgdt 8
+	.word	0x0000, 0x0000		/* dummy */
+	.byte	0x00, 0x00, 0x00, 0x00
+
+// selgdt 0x10 
+/* flat code segment */
+	.word	0xffff, 0x0000		
+	.byte	0x00, 0x9b, 0xcf, 0x00	
+	
+//selgdt 0x18
+/* flat data segment */
+	.word	0xffff, 0x0000		
+	.byte	0x00, 0x93, 0xcf, 0x00	
+
+//selgdt 0x20
+	.word	0x0000, 0x0000		/* dummy */
+	.byte	0x00, 0x00, 0x00, 0x00
+
+#if defined(CONFIG_VGABIOS) && (CONFIG_VGABIOS == 1)
+	// from monty:
+	/* 0x00009a00,0000ffffULL,   20h: 16-bit 64k code at 0x00000000 */
+        /* 0x00009200,0000ffffULL    28h: 16-bit 64k data at 0x00000000 */
+// selgdt 0x28
+/*16-bit 64k code at 0x00000000 */
+	.word 0xffff, 0x0000
+	.byte 0, 0x9a, 0, 0
+
+// selgdt 0x30
+/*16-bit 64k data at 0x00000000 */
+	.word 0xffff, 0x0000
+	.byte 0, 0x92, 0, 0
+#endif // defined(CONFIG_VGABIOS) && (CONFIG_VGABIOS == 1)
+gdt_end:
+
+.code32

Eigenschaftsänderungen: LinuxBIOSv1\src\arch\i386\lib\c_start.S
___________________________________________________________________
Hinzugefügt: svn:keywords
   + Author Date Id Revision
Hinzugefügt: svn:eol-style
   + native

